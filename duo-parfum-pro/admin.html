<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Painel Admin — Duo Parfum</title>
  <link rel="stylesheet" href="./style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600;700&family=Poppins:wght@300;400;500;600&display=swap"
    rel="stylesheet"
  />

  <!-- Firebase -->
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-storage-compat.js"></script>
  <script defer src="./firebase-init.js"></script>
</head>
<body>
  <header class="topbar">
    <div class="container row between center">
      <h2>Duo Parfum — Admin</h2>
      <nav class="row gap">
        <button id="btnLogout" class="btn ghost">Sair</button>
      </nav>
    </div>
  </header>

  <main class="container" style="margin-top:20px">
    <!-- Produtos -->
    <section>
      <h3>Produtos</h3>
      <form id="productForm" class="row wrap gap" style="margin-bottom:14px">
        <input id="pName" class="input" placeholder="Nome" required>
        <input id="pBrand" class="input" placeholder="Marca">
        <input id="pMl" class="input" placeholder="ML">
        <input id="pPrice" class="input" type="number" step="0.01" placeholder="Preço" required>
        <input id="pNotes" class="input" placeholder="Notas">
        <input id="pCategory" class="input" placeholder="Categoria">
        <input id="pImage" type="file" accept="image/*" class="input">
        <div class="row gap">
          <button type="submit" class="btn" id="btnSubmitProduct">Salvar produto</button>
          <button type="button" class="btn ghost" id="btnCancelEdit" style="display:none">Cancelar edição</button>
        </div>
      </form>
      <div id="productList" class="grid"></div>
    </section>

    <hr style="margin:30px 0">

    <!-- Pedidos -->
    <section>
      <h3>Pedidos</h3>
      <div id="orderList" class="grid orders-grid"></div>
    </section>
  </main>

  <script>
    const ADMIN_EMAILS = [
      "guilhermeserraglio03@gmail.com",
      "guilhermeserraglio@gmail.com",
    ];

    document.addEventListener("DOMContentLoaded", async () => {
      const missingConfigMessage = "Configuração do Firebase não encontrada. Verifique as variáveis FIREBASE_WEB_* na Vercel.";

      const configPromise =
        typeof window.getFirebaseConfig === "function"
          ? window.getFirebaseConfig()
          : Promise.reject(new Error(missingConfigMessage));

      let firebaseConfig = null;
      try {
        const resolved = await configPromise;
        if (resolved && typeof resolved === "object") {
          firebaseConfig = resolved;
        }
      } catch (err) {
        console.error("Falha ao carregar configuração do Firebase.", err);
        alert(missingConfigMessage);
        return;
      }

      const hasConfig = firebaseConfig && ["apiKey", "authDomain", "projectId", "appId"].every((key) => {
        const value = firebaseConfig[key];
        return typeof value === "string" && value.trim();
      });

      if (!hasConfig) {
        console.error("Configuração do Firebase inválida recebida:", firebaseConfig);
        alert(missingConfigMessage);
        return;
      }

      if (!firebase.apps?.length) {
        firebase.initializeApp(firebaseConfig);
      }

      const auth = firebase.auth();
      const db = firebase.firestore();
      const storage = firebase.storage();

      const els = {
        form: document.getElementById("productForm"),
        pName: document.getElementById("pName"),
        pBrand: document.getElementById("pBrand"),
        pMl: document.getElementById("pMl"),
        pPrice: document.getElementById("pPrice"),
        pNotes: document.getElementById("pNotes"),
        pCategory: document.getElementById("pCategory"),
        pImage: document.getElementById("pImage"),
        btnSubmit: document.getElementById("btnSubmitProduct"),
        btnCancelEdit: document.getElementById("btnCancelEdit"),
        productList: document.getElementById("productList"),
        orderList: document.getElementById("orderList"),
        btnLogout: document.getElementById("btnLogout")
      };

      const ORDER_STATUS = {
        pending: { key: "pending", label: "Pendente", className: "is-pending" },
        paid: { key: "paid", label: "Pago", className: "is-paid" },
        sent: { key: "sent", label: "Enviado", className: "is-sent" },
        canceled: { key: "canceled", label: "Cancelado", className: "is-canceled" }
      };

      const productsCache = new Map();
      const formState = {
        editingProductId: null,
        currentImageUrl: ""
      };

      const formatCurrency = (value) => {
        const amount = Number(value) || 0;
        return amount.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
      };

      const escapeHtml = (value = "") =>
        value
          .toString()
          .replace(/[&<>"']/g, (match) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[match]));

      const sanitizeTrackingCode = (code = "") =>
        code.toString().toUpperCase().replace(/[^A-Z0-9]/g, "");

      function getOrderStatusInfo(status) {
        const normalized = (status || "pending").toString().toLowerCase();
        return ORDER_STATUS[normalized] || ORDER_STATUS.pending;
      }

      async function callProductsApi(method, payload = {}) {
        const user = auth.currentUser;
        if (!user) {
          const error = new Error("Usuário não autenticado");
          error.displayed = true;
          alert("Faça login novamente para continuar.");
          throw error;
        }

        let token;
        try {
          token = await user.getIdToken(true); // força refresh do token

        } catch (err) {
          console.error("Erro ao obter token de autenticação:", err);
          const error = new Error("Falha ao obter token de autenticação");
          error.displayed = true;
          alert("Não foi possível confirmar sua autenticação. Faça login novamente.");
          throw error;
        }

        const options = {
          method,
          headers: {
            Authorization: `Bearer ${token}`
          }
        };

        if (method !== "GET" && method !== "HEAD") {
          options.headers["Content-Type"] = "application/json";
          options.body = JSON.stringify(payload || {});
        }

        try {
          const response = await fetch("/api/products", options);
          const text = await response.text();
          let data = null;

          if (text) {
            try {
              data = JSON.parse(text);
            } catch (err) {
              console.warn("Resposta da API de produtos não está em JSON válido:", err);
            }
          }

          if (!response.ok) {
            let message = (data && data.error) || "Erro ao processar a solicitação.";
            if (response.status === 401 || response.status === 403) {
              message = "Acesso negado. Somente administradores autorizados podem realizar esta ação.";
            }
            alert(message);
            const error = new Error(message);
            error.status = response.status;
            error.displayed = true;
            error.details = data;
            throw error;
          }

          return data;
        } catch (err) {
          if (!err?.displayed) {
            alert("Não foi possível comunicar com o servidor. Tente novamente.");
            err.displayed = true;
          }
          throw err;
        }
      }

      /* ==== Proteção de acesso ==== */
      auth.onAuthStateChanged(user => {
        if (!user || !ADMIN_EMAILS.includes(user.email)) {
          alert("Acesso negado. Somente administradores.");
          window.location.href = "/";
        }
        /* ==== Mostrar email do admin logado ==== */
auth.onAuthStateChanged(user => {
  if (!user || !ADMIN_EMAILS.includes(user.email)) {
    alert("Acesso negado. Somente administradores.");
    window.location.href = "/";
  } else {
    // Mostra no console
    console.log("✅ Admin logado:", user.email);

    // Exibe na tela (exemplo no header)
    const header = document.querySelector(".topbar .container");
    if (header) {
      const userInfo = document.createElement("span");
      userInfo.textContent = `Logado como: ${user.email}`;
      userInfo.style.marginLeft = "20px";
      userInfo.style.fontSize = "0.9rem";
      userInfo.style.color = "#666";
      header.appendChild(userInfo);
    }
  }
});

      });

      /* ==== Logout ==== */
      els.btnLogout.onclick = () => auth.signOut();

      /* ==== Produtos ==== */
      function resetProductForm() {
        formState.editingProductId = null;
        formState.currentImageUrl = "";

        if (els.form) {
          els.form.reset();
        }
        if (els.pImage) {
          els.pImage.value = "";
        }
        if (els.btnSubmit) {
          els.btnSubmit.textContent = "Salvar produto";
        }
        if (els.btnCancelEdit) {
          els.btnCancelEdit.style.display = "none";
        }
      }

      if (els.btnCancelEdit) {
        els.btnCancelEdit.addEventListener("click", resetProductForm);
      }

      els.form.onsubmit = async (e) => {
        e.preventDefault();
        const file = els.pImage.files[0];
        const isEditing = Boolean(formState.editingProductId);
        const priceValue = parseFloat(els.pPrice.value);

        if (!Number.isFinite(priceValue)) {
          alert("Informe um preço válido.");
          return;
        }

        let imageUrl = formState.currentImageUrl || "";
        const currentProduct = isEditing
          ? productsCache.get(formState.editingProductId) || null
          : null;

        try {
          if (file) {
            const ref = storage.ref("products/" + Date.now() + "-" + file.name);
            await ref.put(file);
            imageUrl = await ref.getDownloadURL();
            if (isEditing) {
              formState.currentImageUrl = imageUrl;
            }
          }

          if (isEditing) {
            const payload = {
              id: formState.editingProductId,
              name: els.pName.value,
              brand: els.pBrand.value,
              ml: els.pMl.value,
              price: priceValue,
              notes: els.pNotes.value,
              category: els.pCategory.value,
              image: imageUrl
            };

            if (currentProduct && typeof currentProduct.featured !== "undefined") {
              payload.featured = Boolean(currentProduct.featured);
            }

            await callProductsApi("PATCH", payload);
          } else {
            await callProductsApi("POST", {
              name: els.pName.value,
              brand: els.pBrand.value,
              ml: els.pMl.value,
              price: priceValue,
              notes: els.pNotes.value,
              category: els.pCategory.value,
              image: imageUrl,
              featured: false
            });
          }

          resetProductForm();
          loadProducts();
        } catch (err) {
          console.error(isEditing ? "Erro ao atualizar produto:" : "Erro ao salvar produto:", err);
          if (!err?.displayed) {
            alert(isEditing ? "Erro ao atualizar produto." : "Erro ao salvar produto.");
          }
        }
      };

      async function loadProducts() {
        const snap = await db.collection("products").orderBy("createdAt", "desc").get();
        els.productList.innerHTML = "";
        productsCache.clear();

        if (snap.empty) {
          els.productList.innerHTML = '<div class="muted">Nenhum produto cadastrado até o momento.</div>';
          return;
        }

        snap.forEach(doc => {
          const data = doc.data() || {};
          const rawPrice = Number(data.price);
          const hasValidPrice = Number.isFinite(rawPrice);
          const product = {
            id: doc.id,
            name: data.name || "",
            brand: data.brand || "",
            ml: data.ml || "",
            price: hasValidPrice ? rawPrice : "",
            notes: data.notes || "",
            category: data.category || "",
            image: data.image || "",
            featured: data.featured
          };

          productsCache.set(product.id, product);

          const priceLabel = formatCurrency(hasValidPrice ? rawPrice : 0);
          const mlLabel = product.ml ? ` (${escapeHtml(product.ml)})` : "";
          const brandLine = product.brand ? `<div class="muted">${escapeHtml(product.brand)}</div>` : "";
          const categoryLine = product.category ? `<div class="muted">Categoria: ${escapeHtml(product.category)}</div>` : "";
          const notesLine = product.notes ? `<div class="muted">Notas: ${escapeHtml(product.notes)}</div>` : "";
          const imageSrc = escapeHtml(product.image || "https://picsum.photos/200");
          const altText = escapeHtml(product.name || "Produto");

          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <img src="${imageSrc}" alt="${altText}">
            <div class="pad">
              <div><strong>${escapeHtml(product.name)}</strong>${mlLabel}</div>
              ${brandLine}
              <div class="muted">${escapeHtml(priceLabel)}</div>
              ${categoryLine}
              ${notesLine}
              <div class="row gap" style="margin-top:8px">
                <button class="btn small" onclick="editProduct('${product.id}')">Editar</button>
                <button class="btn small" onclick="deleteProduct('${product.id}')">Excluir</button>
              </div>
            </div>`;
          els.productList.appendChild(card);
        });
      }

      window.deleteProduct = async (id) => {
        if (!confirm("Excluir produto?")) return;
        try {
          await callProductsApi("DELETE", { id });
          loadProducts();
        } catch (err) {
          console.error("Erro ao excluir produto:", err);
          if (!err?.displayed) {
            alert("Erro ao excluir produto.");
          }
        }
      };

      window.editProduct = (id) => {
        const product = productsCache.get(id);
        if (!product) {
          alert("Produto não encontrado.");
          return;
        }

        formState.editingProductId = product.id;
        formState.currentImageUrl = product.image || "";

        els.pName.value = product.name || "";
        els.pBrand.value = product.brand || "";
        els.pMl.value = product.ml || "";

        if (typeof product.price === "number") {
          els.pPrice.value = product.price.toString();
        } else {
          els.pPrice.value = "";
        }

        els.pNotes.value = product.notes || "";
        els.pCategory.value = product.category || "";

        if (els.pImage) {
          els.pImage.value = "";
        }
        if (els.btnSubmit) {
          els.btnSubmit.textContent = "Atualizar produto";
        }
        if (els.btnCancelEdit) {
          els.btnCancelEdit.style.display = "inline-flex";
        }

        els.pName.focus();
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      loadProducts();

      /* ==== Pedidos ==== */
      async function loadOrders() {
        const snap = await db.collection("orders").orderBy("createdAt", "desc").get();
        els.orderList.innerHTML = "";

        if (snap.empty) {
          els.orderList.innerHTML = '<div class="order-card__empty muted">Nenhum pedido registrado até o momento.</div>';
          return;
        }

        snap.forEach(doc => {
          const data = doc.data();
          const statusInfo = getOrderStatusInfo(data.status);
          const card = document.createElement("div");
          card.className = `card order-card ${statusInfo.className}`;

          const items = Array.isArray(data.items) ? data.items : [];
          const itemsList = items
            .map(item => {
              const quantity = item?.qty || 1;
              const name = escapeHtml(item?.name || "Item");
              const ml = item?.ml ? ` (${escapeHtml(item.ml)})` : "";
              return `<li>${quantity}x ${name}${ml}</li>`;
            })
            .join("");

          const shipping = typeof data.shipping === "object" && data.shipping ? data.shipping : {};
          const shippingMethod = (shipping.method || data.customer?.shippingMethod || "").toString().toLowerCase();
          const shippingCost = Number(shipping.cost);
          const shippingService = (shipping.service || "Correios").toString().trim();
          const shippingEstimate = shipping.deliveryEstimate || "";
          const shippingParts = [];
          if (shippingMethod === "pickup") {
            shippingParts.push("Retirada no local");
            if (shipping.instructions) {
              shippingParts.push(escapeHtml(shipping.instructions));
            }
          } else {
            const serviceLabel = shippingService && shippingService.toLowerCase() !== "correios"
              ? `Correios — ${escapeHtml(shippingService)}`
              : "Correios";
            shippingParts.push(serviceLabel);
            if (Number.isFinite(shippingCost) && shippingCost > 0) {
              shippingParts.push(formatCurrency(shippingCost));
            }
            if (shippingEstimate) {
              shippingParts.push(escapeHtml(shippingEstimate));
            }
            if (shipping.originLabel) {
              shippingParts.push(`Postagem: ${escapeHtml(shipping.originLabel)}`);
            }
          }
          const shippingSummary = shippingParts.join(" • ");

          const trackingCode = sanitizeTrackingCode(data.trackingCode || shipping?.trackingCode || "");
          const contactLine = [data.customer?.email, data.customer?.phone].filter(Boolean).join(" · ");
          const addressLine = shippingMethod === "pickup"
            ? "Retirada no local"
            : [shipping?.cep || data.customer?.cep, data.customer?.address, data.customer?.city, data.customer?.state]
                .filter(Boolean)
                .join(" · ");
          const createdAt = typeof data.createdAt?.toDate === "function" ? data.createdAt.toDate() : null;
          const createdAtLine = createdAt ? `Realizado em ${createdAt.toLocaleString("pt-BR")}` : "";
          const metaLines = [contactLine, addressLine, createdAtLine]
            .filter(Boolean)
            .map(line => `<p class="order-card__meta-line">${escapeHtml(line)}</p>`)
            .join("");

          const trackingGeneratedAt = typeof shipping?.trackingGeneratedAt?.toDate === "function"
            ? shipping.trackingGeneratedAt.toDate()
            : null;
          const trackingGeneratedNote = trackingGeneratedAt
            ? `<span class="order-card__meta-line muted">${escapeHtml(shipping?.trackingGeneratedBy === "automatic" ? "Gerado automaticamente" : "Atualizado")} em ${escapeHtml(trackingGeneratedAt.toLocaleString("pt-BR"))}</span>`
            : "";

          const trackingHtml = `
            <div class="order-card__tracking-admin">
              <span class="order-card__label">Rastreio Correios</span>
              <div class="order-card__tracking-actions">
                <input class="input order-card__tracking-input" data-tracking-input="${doc.id}" placeholder="Ex: LB123456789BR" value="${escapeHtml(trackingCode)}">
                <button class="btn small ghost" onclick="saveTracking('${doc.id}')">Salvar</button>
                ${trackingCode ? `<a class="btn small ghost" href="https://rastreamento.correios.com.br/app/index.php?codigo=${trackingCode}" target="_blank" rel="noreferrer">Ver no Correios</a>` : ""}
              </div>
              ${trackingGeneratedNote}
            </div>`;

          const statusButtons = [
            { value: "paid", label: "Pago" },
            { value: "sent", label: "Enviado" },
            { value: "canceled", label: "Cancelado" }
          ];

          const actionsHtml = statusButtons
            .map(button => {
              const isCurrent = button.value === statusInfo.key;
              const activeClass = isCurrent ? " is-current" : "";
              return `<button class="btn small ghost${activeClass}" onclick="updateOrder('${doc.id}','${button.value}')">${button.label}</button>`;
            })
            .join("");

          card.innerHTML = `
            <div class="pad order-card__content">
              <div class="order-card__header">
                <div>
                  <p class="order-card__title">${escapeHtml(data.customer?.name || "Cliente")}</p>
                  ${metaLines}
                </div>
                <span class="order-card__status-badge ${statusInfo.className}">${statusInfo.label}</span>
              </div>
              <div class="order-card__details">
                <div>
                  <span class="order-card__label">Pagamento</span>
                  <span class="order-card__value">${escapeHtml(data.customer?.payment || "Não informado")}</span>
                </div>
                <div>
                  <span class="order-card__label">Entrega</span>
                  <span class="order-card__value">${shippingSummary || "Em confirmação"}</span>
                </div>
                <div>
                  <span class="order-card__label">Total</span>
                  <span class="order-card__value">${formatCurrency(data.total)}</span>
                </div>
              </div>
              <div class="order-card__items">
                <span class="order-card__label">Itens</span>
                <ul>${itemsList || "<li class='muted'>Nenhum item registrado.</li>"}</ul>
              </div>
              ${trackingHtml}
              <div class="order-card__actions">
                <button class="btn small ghost danger" onclick="deleteOrder('${doc.id}')">Excluir</button>
                <div class="order-card__actions-group">
                  ${actionsHtml}
                </div>
              </div>
            </div>`;

          els.orderList.appendChild(card);
        });
      }

      window.updateOrder = async (id, status) => {
        try {
          await db.collection("orders").doc(id).update({ status });
          loadOrders();
        } catch (err) {
          console.error("Erro ao atualizar pedido:", err);
          alert("Não foi possível atualizar o status do pedido.");
        }
      };

      window.saveTracking = async (id) => {
        const input = document.querySelector(`[data-tracking-input="${id}"]`);
        if (!input) {
          alert("Campo de rastreio não encontrado.");
          return;
        }

        const sanitized = sanitizeTrackingCode(input.value || "");
        input.value = sanitized;

        const updatePayload = sanitized
          ? {
              trackingCode: sanitized,
              "shipping.trackingCode": sanitized,
              "shipping.trackingGeneratedAt": firebase.firestore.FieldValue.serverTimestamp(),
              "shipping.trackingGeneratedBy": "manual"
            }
          : {
              trackingCode: firebase.firestore.FieldValue.delete(),
              "shipping.trackingCode": firebase.firestore.FieldValue.delete(),
              "shipping.trackingGeneratedAt": firebase.firestore.FieldValue.delete(),
              "shipping.trackingGeneratedBy": firebase.firestore.FieldValue.delete()
            };

        try {
          await db.collection("orders").doc(id).update(updatePayload);
          alert(sanitized ? "Código de rastreio atualizado." : "Código de rastreio removido.");
          loadOrders();
        } catch (err) {
          console.error("Erro ao salvar código de rastreio:", err);
          alert("Não foi possível atualizar o código de rastreio.");
        }
      };

      window.deleteOrder = async (id) => {
        if (!confirm("Excluir este pedido? Essa ação não poderá ser desfeita.")) {
          return;
        }

        try {
          await db.collection("orders").doc(id).delete();
          loadOrders();
        } catch (err) {
          console.error("Erro ao excluir pedido:", err);
          alert("Não foi possível excluir o pedido.");
        }
      };

      loadOrders();
    });
  </script>
</body>
</html>
