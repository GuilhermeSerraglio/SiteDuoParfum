<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Painel Admin — Duo Parfum</title>
  <link rel="stylesheet" href="./style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600;700&family=Poppins:wght@300;400;500;600&display=swap"
    rel="stylesheet"
  />

  <!-- Firebase -->
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.4/firebase-storage-compat.js"></script>
  <script defer src="./firebase-init.js"></script>
</head>
<body>
  <header class="topbar">
    <div class="container row between center">
      <h2>Duo Parfum — Admin</h2>
      <nav class="row gap">
        <button id="btnLogout" class="btn ghost">Sair</button>
      </nav>
    </div>
  </header>

  <main class="container" style="margin-top:20px">
    <!-- Produtos -->
    <section>
      <h3>Produtos</h3>
      <form id="productForm" class="row wrap gap" style="margin-bottom:14px">
        <input id="pName" class="input" placeholder="Nome" required>
        <input id="pBrand" class="input" placeholder="Marca">
        <input id="pMl" class="input" placeholder="ML">
        <input id="pPrice" class="input" type="number" step="0.01" placeholder="Preço" required>
        <input id="pNotes" class="input" placeholder="Notas">
        <input id="pCategory" class="input" placeholder="Categoria">
        <input id="pImage" type="file" accept="image/*" class="input">
        <div class="row gap">
          <button type="submit" class="btn" id="btnSubmitProduct">Salvar produto</button>
          <button type="button" class="btn ghost" id="btnCancelEdit" style="display:none">Cancelar edição</button>
        </div>
      </form>
      <div id="productList" class="grid"></div>
    </section>

    <hr style="margin:30px 0">

    <!-- Banner -->
    <section>
      <h3>Banner de destaques</h3>
      <p class="muted" style="margin-bottom:12px">Cadastre aqui as imagens que serão exibidas no banner rotativo da página inicial.</p>
      <form id="heroForm" class="row wrap gap" style="margin-bottom:14px">
        <input id="heroTitle" class="input" placeholder="Título" required>
        <input id="heroTag" class="input" placeholder="Etiqueta (ex: Lançamento)">
        <input id="heroOrder" class="input" type="number" step="1" min="0" placeholder="Ordem">
        <input id="heroAlt" class="input" placeholder="Texto alternativo da imagem">
        <textarea id="heroDescription" class="input" placeholder="Descrição" rows="2" style="flex:1 1 100%"></textarea>
        <label class="hero-form-checkbox" style="flex:1 1 200px">
          <input id="heroActive" type="checkbox" checked>
          <span>Visível no site</span>
        </label>
        <input id="heroImage" type="file" accept="image/*" class="input" style="flex:1 1 260px">
        <div class="row gap">
          <button type="submit" class="btn" id="btnSaveHero">Salvar banner</button>
          <button type="button" class="btn ghost" id="btnCancelHeroEdit" style="display:none">Cancelar edição</button>
        </div>
      </form>

      <div id="heroList" class="grid"></div>
    </section>

    <hr style="margin:30px 0">

    <!-- Pedidos -->
    <section>
      <h3>Pedidos</h3>
      <div id="orderList" class="grid orders-grid"></div>
    </section>
  </main>

  <script>
    const ADMIN_EMAILS = [
      "guilhermeserraglio03@gmail.com",
      "guilhermeserraglio@gmail.com",
    ];

    document.addEventListener("DOMContentLoaded", async () => {
      const missingConfigMessage = "Configuração do Firebase não encontrada. Verifique as variáveis FIREBASE_WEB_* na Vercel.";

      const configPromise =
        typeof window.getFirebaseConfig === "function"
          ? window.getFirebaseConfig()
          : Promise.reject(new Error(missingConfigMessage));

      let firebaseConfig = null;
      try {
        const resolved = await configPromise;
        if (resolved && typeof resolved === "object") {
          firebaseConfig = resolved;
        }
      } catch (err) {
        console.error("Falha ao carregar configuração do Firebase.", err);
        alert(missingConfigMessage);
        return;
      }

      const hasConfig = firebaseConfig && ["apiKey", "authDomain", "projectId", "appId"].every((key) => {
        const value = firebaseConfig[key];
        return typeof value === "string" && value.trim();
      });

      if (!hasConfig) {
        console.error("Configuração do Firebase inválida recebida:", firebaseConfig);
        alert(missingConfigMessage);
        return;
      }

      if (!firebase.apps?.length) {
        firebase.initializeApp(firebaseConfig);
      }

      const auth = firebase.auth();
      const db = firebase.firestore();
      const storage = firebase.storage();

      const els = {
        form: document.getElementById("productForm"),
        pName: document.getElementById("pName"),
        pBrand: document.getElementById("pBrand"),
        pMl: document.getElementById("pMl"),
        pPrice: document.getElementById("pPrice"),
        pNotes: document.getElementById("pNotes"),
        pCategory: document.getElementById("pCategory"),
        pImage: document.getElementById("pImage"),
        btnSubmit: document.getElementById("btnSubmitProduct"),
        btnCancelEdit: document.getElementById("btnCancelEdit"),
        productList: document.getElementById("productList"),
        heroForm: document.getElementById("heroForm"),
        heroTitle: document.getElementById("heroTitle"),
        heroTag: document.getElementById("heroTag"),
        heroOrder: document.getElementById("heroOrder"),
        heroAlt: document.getElementById("heroAlt"),
        heroDescription: document.getElementById("heroDescription"),
        heroActive: document.getElementById("heroActive"),
        heroImage: document.getElementById("heroImage"),
        heroList: document.getElementById("heroList"),
        btnSaveHero: document.getElementById("btnSaveHero"),
        btnCancelHeroEdit: document.getElementById("btnCancelHeroEdit"),
        orderList: document.getElementById("orderList"),
        btnLogout: document.getElementById("btnLogout")
      };

      const ORDER_STATUS = {
        pending: { key: "pending", label: "Pendente", className: "is-pending" },
        paid: { key: "paid", label: "Pago", className: "is-paid" },
        sent: { key: "sent", label: "Enviado", className: "is-sent" },
        canceled: { key: "canceled", label: "Cancelado", className: "is-canceled" }
      };

      const productsCache = new Map();
      const formState = {
        editingProductId: null,
        currentImageUrl: ""
      };

      const heroFormState = {
        editingHeroId: null,
        currentImageUrl: ""
      };

      const formatCurrency = (value) => {
        const amount = Number(value) || 0;
        return amount.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
      };

      const escapeHtml = (value = "") =>
        value
          .toString()
          .replace(/[&<>"']/g, (match) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[match]));

      const sanitizeImage = (value = "") => {
        const trimmed = typeof value === "string" ? value.trim() : "";
        return trimmed || "https://picsum.photos/seed/duoparfum/600/400";
      };

      const sanitizeTrackingCode = (code = "") =>
        code.toString().toUpperCase().replace(/[^A-Z0-9]/g, "");

      function getOrderStatusInfo(status) {
        const normalized = (status || "pending").toString().toLowerCase();
        return ORDER_STATUS[normalized] || ORDER_STATUS.pending;
      }

      async function callProductsApi(method, payload = {}) {
        const user = auth.currentUser;
        if (!user) {
          const error = new Error("Usuário não autenticado");
          error.displayed = true;
          alert("Faça login novamente para continuar.");
          throw error;
        }

        let token;
        try {
          token = await user.getIdToken(true); // força refresh do token

        } catch (err) {
          console.error("Erro ao obter token de autenticação:", err);
          const error = new Error("Falha ao obter token de autenticação");
          error.displayed = true;
          alert("Não foi possível confirmar sua autenticação. Faça login novamente.");
          throw error;
        }

        const options = {
          method,
          headers: {
            Authorization: `Bearer ${token}`
          }
        };

        if (method !== "GET" && method !== "HEAD") {
          options.headers["Content-Type"] = "application/json";
          options.body = JSON.stringify(payload || {});
        }

        try {
          const response = await fetch("/api/products", options);
          const text = await response.text();
          let data = null;

          if (text) {
            try {
              data = JSON.parse(text);
            } catch (err) {
              console.warn("Resposta da API de produtos não está em JSON válido:", err);
            }
          }

          if (!response.ok) {
            let message = (data && data.error) || "Erro ao processar a solicitação.";
            if (response.status === 401 || response.status === 403) {
              message = "Acesso negado. Somente administradores autorizados podem realizar esta ação.";
            }
            alert(message);
            const error = new Error(message);
            error.status = response.status;
            error.displayed = true;
            error.details = data;
            throw error;
          }

          return data;
        } catch (err) {
          if (!err?.displayed) {
            alert("Não foi possível comunicar com o servidor. Tente novamente.");
            err.displayed = true;
          }
          throw err;
        }
      }

      /* ==== Proteção de acesso ==== */
      auth.onAuthStateChanged(user => {
        if (!user || !ADMIN_EMAILS.includes(user.email)) {
          alert("Acesso negado. Somente administradores.");
          window.location.href = "/";
        }
        /* ==== Mostrar email do admin logado ==== */
auth.onAuthStateChanged(user => {
  if (!user || !ADMIN_EMAILS.includes(user.email)) {
    alert("Acesso negado. Somente administradores.");
    window.location.href = "/";
  } else {
    // Mostra no console
    console.log("✅ Admin logado:", user.email);

    // Exibe na tela (exemplo no header)
    const header = document.querySelector(".topbar .container");
    if (header) {
      const userInfo = document.createElement("span");
      userInfo.textContent = `Logado como: ${user.email}`;
      userInfo.style.marginLeft = "20px";
      userInfo.style.fontSize = "0.9rem";
      userInfo.style.color = "#666";
      header.appendChild(userInfo);
    }
  }
});

      });

      /* ==== Logout ==== */
      els.btnLogout.onclick = () => auth.signOut();

      /* ==== Produtos ==== */
      function resetProductForm() {
        formState.editingProductId = null;
        formState.currentImageUrl = "";

        if (els.form) {
          els.form.reset();
        }
        if (els.pImage) {
          els.pImage.value = "";
        }
        if (els.btnSubmit) {
          els.btnSubmit.textContent = "Salvar produto";
        }
        if (els.btnCancelEdit) {
          els.btnCancelEdit.style.display = "none";
        }
      }

      if (els.btnCancelEdit) {
        els.btnCancelEdit.addEventListener("click", resetProductForm);
      }

      els.form.onsubmit = async (e) => {
        e.preventDefault();
        const file = els.pImage.files[0];
        const isEditing = Boolean(formState.editingProductId);
        const priceValue = parseFloat(els.pPrice.value);

        if (!Number.isFinite(priceValue)) {
          alert("Informe um preço válido.");
          return;
        }

        let imageUrl = formState.currentImageUrl || "";
        const currentProduct = isEditing
          ? productsCache.get(formState.editingProductId) || null
          : null;

        try {
          if (file) {
            const ref = storage.ref("products/" + Date.now() + "-" + file.name);
            await ref.put(file);
            imageUrl = await ref.getDownloadURL();
            if (isEditing) {
              formState.currentImageUrl = imageUrl;
            }
          }

          if (isEditing) {
            const payload = {
              id: formState.editingProductId,
              name: els.pName.value,
              brand: els.pBrand.value,
              ml: els.pMl.value,
              price: priceValue,
              notes: els.pNotes.value,
              category: els.pCategory.value,
              image: imageUrl
            };

            if (currentProduct && typeof currentProduct.featured !== "undefined") {
              payload.featured = Boolean(currentProduct.featured);
            }

            await callProductsApi("PATCH", payload);
          } else {
            await callProductsApi("POST", {
              name: els.pName.value,
              brand: els.pBrand.value,
              ml: els.pMl.value,
              price: priceValue,
              notes: els.pNotes.value,
              category: els.pCategory.value,
              image: imageUrl,
              featured: false
            });
          }

          resetProductForm();
          loadProducts();
        } catch (err) {
          console.error(isEditing ? "Erro ao atualizar produto:" : "Erro ao salvar produto:", err);
          if (!err?.displayed) {
            alert(isEditing ? "Erro ao atualizar produto." : "Erro ao salvar produto.");
          }
        }
      };

      async function loadProducts() {
        const snap = await db.collection("products").orderBy("createdAt", "desc").get();
        els.productList.innerHTML = "";
        productsCache.clear();

        if (snap.empty) {
          els.productList.innerHTML = '<div class="muted">Nenhum produto cadastrado até o momento.</div>';
          return;
        }

        snap.forEach(doc => {
          const data = doc.data() || {};
          const rawPrice = Number(data.price);
          const hasValidPrice = Number.isFinite(rawPrice);
          const product = {
            id: doc.id,
            name: data.name || "",
            brand: data.brand || "",
            ml: data.ml || "",
            price: hasValidPrice ? rawPrice : "",
            notes: data.notes || "",
            category: data.category || "",
            image: data.image || "",
            featured: data.featured
          };

          productsCache.set(product.id, product);

          const priceLabel = formatCurrency(hasValidPrice ? rawPrice : 0);
          const mlLabel = product.ml ? ` (${escapeHtml(product.ml)})` : "";
          const brandLine = product.brand ? `<div class="muted">${escapeHtml(product.brand)}</div>` : "";
          const categoryLine = product.category ? `<div class="muted">Categoria: ${escapeHtml(product.category)}</div>` : "";
          const notesLine = product.notes ? `<div class="muted">Notas: ${escapeHtml(product.notes)}</div>` : "";
          const imageSrc = escapeHtml(product.image || "https://picsum.photos/200");
          const altText = escapeHtml(product.name || "Produto");

          const card = document.createElement("div");
          card.className = "card";
          card.innerHTML = `
            <img src="${imageSrc}" alt="${altText}">
            <div class="pad">
              <div><strong>${escapeHtml(product.name)}</strong>${mlLabel}</div>
              ${brandLine}
              <div class="muted">${escapeHtml(priceLabel)}</div>
              ${categoryLine}
              ${notesLine}
              <div class="row gap" style="margin-top:8px">
                <button class="btn small" onclick="editProduct('${product.id}')">Editar</button>
                <button class="btn small" onclick="deleteProduct('${product.id}')">Excluir</button>
              </div>
            </div>`;
          els.productList.appendChild(card);
        });
      }

      window.deleteProduct = async (id) => {
        if (!confirm("Excluir produto?")) return;
        try {
          await callProductsApi("DELETE", { id });
          loadProducts();
        } catch (err) {
          console.error("Erro ao excluir produto:", err);
          if (!err?.displayed) {
            alert("Erro ao excluir produto.");
          }
        }
      };

      window.editProduct = (id) => {
        const product = productsCache.get(id);
        if (!product) {
          alert("Produto não encontrado.");
          return;
        }

        formState.editingProductId = product.id;
        formState.currentImageUrl = product.image || "";

        els.pName.value = product.name || "";
        els.pBrand.value = product.brand || "";
        els.pMl.value = product.ml || "";

        if (typeof product.price === "number") {
          els.pPrice.value = product.price.toString();
        } else {
          els.pPrice.value = "";
        }

        els.pNotes.value = product.notes || "";
        els.pCategory.value = product.category || "";

        if (els.pImage) {
          els.pImage.value = "";
        }
        if (els.btnSubmit) {
          els.btnSubmit.textContent = "Atualizar produto";
        }
        if (els.btnCancelEdit) {
          els.btnCancelEdit.style.display = "inline-flex";
        }

        els.pName.focus();
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      /* ==== Banner ==== */
      const heroCache = new Map();

      function resetHeroForm() {
        heroFormState.editingHeroId = null;
        heroFormState.currentImageUrl = "";

        if (els.heroForm) {
          els.heroForm.reset();
        }
        if (els.heroActive) {
          els.heroActive.checked = true;
        }
        if (els.heroImage) {
          els.heroImage.value = "";
        }
        if (els.btnSaveHero) {
          els.btnSaveHero.textContent = "Salvar banner";
        }
        if (els.btnCancelHeroEdit) {
          els.btnCancelHeroEdit.style.display = "none";
        }
      }

      if (els.btnCancelHeroEdit) {
        els.btnCancelHeroEdit.addEventListener("click", resetHeroForm);
      }

      if (els.heroForm) {
        els.heroForm.addEventListener("submit", async (event) => {
          event.preventDefault();

          const isEditing = Boolean(heroFormState.editingHeroId);
          const file = els.heroImage?.files?.[0];
          let imageUrl = heroFormState.currentImageUrl || "";

          if (!isEditing && !file) {
            alert("Envie uma imagem para o banner.");
            return;
          }

          try {
            if (file) {
              const ref = storage.ref("hero-banners/" + Date.now() + "-" + file.name);
              await ref.put(file);
              imageUrl = await ref.getDownloadURL();
              heroFormState.currentImageUrl = imageUrl;
            }

            if (!imageUrl) {
              alert("Não foi possível obter a imagem do banner.");
              return;
            }

            const orderValue = Number.parseInt(els.heroOrder?.value, 10);
            const payload = {
              title: els.heroTitle?.value?.trim() || "",
              description: els.heroDescription?.value?.trim() || "",
              tag: els.heroTag?.value?.trim() || "",
              alt: els.heroAlt?.value?.trim() || "",
              image: imageUrl,
              active: Boolean(els.heroActive?.checked)
            };

            if (Number.isFinite(orderValue)) {
              payload.order = orderValue;
            } else if (isEditing) {
              payload.order = firebase.firestore.FieldValue.delete();
            }

            if (isEditing) {
              await db.collection("heroSlides").doc(heroFormState.editingHeroId).update(payload);
            } else {
              await db.collection("heroSlides").add({
                ...payload,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
              });
            }

            resetHeroForm();
            loadHeroBanners();
          } catch (err) {
            console.error(isEditing ? "Erro ao atualizar banner:" : "Erro ao salvar banner:", err);
            alert("Não foi possível salvar o banner.");
          }
        });
      }

      async function loadHeroBanners() {
        if (!els.heroList) return;

        els.heroList.innerHTML = "<div class='muted'>Carregando banners...</div>";
        heroCache.clear();

        try {
          const snap = await db.collection("heroSlides").get();
          const banners = [];
          snap.forEach(doc => {
            const data = doc.data() || {};
            const hasOrder = typeof data.order === "number" && Number.isFinite(data.order);
            const orderValue = hasOrder ? data.order : Number.MAX_SAFE_INTEGER;
            const createdAt = typeof data.createdAt?.toDate === "function" ? data.createdAt.toDate() : null;
            banners.push({
              id: doc.id,
              data,
              order: orderValue,
              createdAt
            });
            heroCache.set(doc.id, {
              id: doc.id,
              title: data.title || "",
              description: data.description || "",
              tag: data.tag || "",
              alt: data.alt || "",
              image: data.image || "",
              order: hasOrder ? data.order : "",
              active: data.active !== false
            });
          });

          banners.sort((a, b) => {
            if (a.order !== b.order) return a.order - b.order;
            const timeA = a.createdAt ? a.createdAt.getTime() : 0;
            const timeB = b.createdAt ? b.createdAt.getTime() : 0;
            return timeA - timeB;
          });

          if (!banners.length) {
            els.heroList.innerHTML = '<div class="muted">Nenhum banner cadastrado ainda.</div>';
            return;
          }

          els.heroList.innerHTML = "";

          banners.forEach(({ id, data }) => {
            const card = document.createElement("article");
            const isActive = data.active !== false;
            const hasOrder = typeof data.order === "number" && Number.isFinite(data.order);
            card.className = `admin-hero-card${isActive ? "" : " is-inactive"}`;
            const orderLabel = hasOrder ? data.order : "-";
            const altText = data.alt || data.title || "Banner";

            card.innerHTML = `
              <div class="admin-hero-thumb-wrap">
                <img class="admin-hero-thumb" src="${sanitizeImage(data.image)}" alt="${escapeHtml(altText)}">
              </div>
              <div class="admin-hero-info">
                <div class="admin-hero-title">${escapeHtml(data.title || "Sem título")}</div>
                ${data.description ? `<p class="admin-hero-description">${escapeHtml(data.description)}</p>` : ""}
                <div class="admin-hero-meta">
                  ${data.tag ? `<span class="admin-hero-tag">${escapeHtml(data.tag)}</span>` : ""}
                  <span class="admin-hero-order">Ordem: ${escapeHtml(orderLabel.toString())}</span>
                  <span class="admin-hero-status ${isActive ? "is-on" : "is-off"}">${isActive ? "Visível" : "Oculto"}</span>
                </div>
              </div>
              <div class="admin-hero-actions">
                <button class="btn small ghost" onclick="editHeroSlide('${id}')">Editar</button>
                <button class="btn small ghost" onclick="toggleHeroVisibility('${id}', ${isActive ? "false" : "true"})">${isActive ? "Ocultar" : "Ativar"}</button>
                <button class="btn small ghost danger" onclick="deleteHeroSlide('${id}')">Excluir</button>
              </div>
            `;

            els.heroList.appendChild(card);
          });
        } catch (err) {
          console.error("Erro ao carregar banners:", err);
          els.heroList.innerHTML = '<div class="muted">Erro ao carregar banners.</div>';
        }
      }

      window.editHeroSlide = (id) => {
        const slide = heroCache.get(id);
        if (!slide) {
          alert("Banner não encontrado.");
          return;
        }

        heroFormState.editingHeroId = slide.id;
        heroFormState.currentImageUrl = slide.image || "";

        if (els.heroTitle) els.heroTitle.value = slide.title || "";
        if (els.heroTag) els.heroTag.value = slide.tag || "";
        if (els.heroOrder) els.heroOrder.value = slide.order !== "" ? slide.order : "";
        if (els.heroAlt) els.heroAlt.value = slide.alt || "";
        if (els.heroDescription) els.heroDescription.value = slide.description || "";
        if (els.heroActive) els.heroActive.checked = slide.active !== false;
        if (els.heroImage) els.heroImage.value = "";
        if (els.btnSaveHero) els.btnSaveHero.textContent = "Atualizar banner";
        if (els.btnCancelHeroEdit) els.btnCancelHeroEdit.style.display = "inline-flex";

        window.scrollTo({ top: els.heroForm?.offsetTop || 0, behavior: "smooth" });
        els.heroTitle?.focus();
      };

      window.toggleHeroVisibility = async (id, shouldActivate) => {
        try {
          await db.collection("heroSlides").doc(id).update({ active: Boolean(shouldActivate) });
          loadHeroBanners();
        } catch (err) {
          console.error("Erro ao atualizar visibilidade do banner:", err);
          alert("Não foi possível alterar a visibilidade.");
        }
      };

      window.deleteHeroSlide = async (id) => {
        if (!confirm("Excluir este banner?")) {
          return;
        }

        try {
          await db.collection("heroSlides").doc(id).delete();
          loadHeroBanners();
          if (heroFormState.editingHeroId === id) {
            resetHeroForm();
          }
        } catch (err) {
          console.error("Erro ao excluir banner:", err);
          alert("Não foi possível excluir o banner.");
        }
      };

      loadHeroBanners();

      loadProducts();

      /* ==== Pedidos ==== */
      async function loadOrders() {
        const snap = await db.collection("orders").orderBy("createdAt", "desc").get();
        els.orderList.innerHTML = "";

        if (snap.empty) {
          els.orderList.innerHTML = '<div class="order-card__empty muted">Nenhum pedido registrado até o momento.</div>';
          return;
        }

        snap.forEach(doc => {
          const data = doc.data();
          const statusInfo = getOrderStatusInfo(data.status);
          const card = document.createElement("div");
          card.className = `card order-card ${statusInfo.className}`;

          const items = Array.isArray(data.items) ? data.items : [];
          const itemsList = items
            .map(item => {
              const quantity = item?.qty || 1;
              const name = escapeHtml(item?.name || "Item");
              const ml = item?.ml ? ` (${escapeHtml(item.ml)})` : "";
              return `<li>${quantity}x ${name}${ml}</li>`;
            })
            .join("");

          const trackingCode = sanitizeTrackingCode(data.trackingCode || data.shipping?.trackingCode || "");
          const contactLine = [data.customer?.email, data.customer?.phone].filter(Boolean).join(" · ");
          const addressLine = [data.customer?.cep, data.customer?.address, data.customer?.city, data.customer?.state]
            .filter(Boolean)
            .join(" · ");
          const createdAt = typeof data.createdAt?.toDate === "function" ? data.createdAt.toDate() : null;
          const createdAtLine = createdAt ? `Realizado em ${createdAt.toLocaleString("pt-BR")}` : "";
          const metaLines = [contactLine, addressLine, createdAtLine]
            .filter(Boolean)
            .map(line => `<p class="order-card__meta-line">${escapeHtml(line)}</p>`)
            .join("");

          const trackingHtml = `
            <div class="order-card__tracking-admin">
              <span class="order-card__label">Rastreio Correios</span>
              <div class="order-card__tracking-actions">
                <input class="input order-card__tracking-input" data-tracking-input="${doc.id}" placeholder="Ex: LB123456789BR" value="${escapeHtml(trackingCode)}">
                <button class="btn small ghost" onclick="saveTracking('${doc.id}')">Salvar</button>
                ${trackingCode ? `<a class="btn small ghost" href="https://rastreamento.correios.com.br/app/index.php?codigo=${trackingCode}" target="_blank" rel="noreferrer">Ver no Correios</a>` : ""}
              </div>
            </div>`;

          const statusButtons = [
            { value: "paid", label: "Pago" },
            { value: "sent", label: "Enviado" },
            { value: "canceled", label: "Cancelado" }
          ];

          const actionsHtml = statusButtons
            .map(button => {
              const isCurrent = button.value === statusInfo.key;
              const activeClass = isCurrent ? " is-current" : "";
              return `<button class="btn small ghost${activeClass}" onclick="updateOrder('${doc.id}','${button.value}')">${button.label}</button>`;
            })
            .join("");

          card.innerHTML = `
            <div class="pad order-card__content">
              <div class="order-card__header">
                <div>
                  <p class="order-card__title">${escapeHtml(data.customer?.name || "Cliente")}</p>
                  ${metaLines}
                </div>
                <span class="order-card__status-badge ${statusInfo.className}">${statusInfo.label}</span>
              </div>
              <div class="order-card__details">
                <div>
                  <span class="order-card__label">Pagamento</span>
                  <span class="order-card__value">${escapeHtml(data.customer?.payment || "Não informado")}</span>
                </div>
                <div>
                  <span class="order-card__label">Total</span>
                  <span class="order-card__value">${formatCurrency(data.total)}</span>
                </div>
              </div>
              <div class="order-card__items">
                <span class="order-card__label">Itens</span>
                <ul>${itemsList || "<li class='muted'>Nenhum item registrado.</li>"}</ul>
              </div>
              ${trackingHtml}
              <div class="order-card__actions">
                <button class="btn small ghost danger" onclick="deleteOrder('${doc.id}')">Excluir</button>
                <div class="order-card__actions-group">
                  ${actionsHtml}
                </div>
              </div>
            </div>`;

          els.orderList.appendChild(card);
        });
      }

      window.updateOrder = async (id, status) => {
        try {
          await db.collection("orders").doc(id).update({ status });
          loadOrders();
        } catch (err) {
          console.error("Erro ao atualizar pedido:", err);
          alert("Não foi possível atualizar o status do pedido.");
        }
      };

      window.saveTracking = async (id) => {
        const input = document.querySelector(`[data-tracking-input="${id}"]`);
        if (!input) {
          alert("Campo de rastreio não encontrado.");
          return;
        }

        const sanitized = sanitizeTrackingCode(input.value || "");
        input.value = sanitized;

        const updatePayload = sanitized
          ? { trackingCode: sanitized }
          : { trackingCode: firebase.firestore.FieldValue.delete() };

        try {
          await db.collection("orders").doc(id).update(updatePayload);
          alert(sanitized ? "Código de rastreio atualizado." : "Código de rastreio removido.");
          loadOrders();
        } catch (err) {
          console.error("Erro ao salvar código de rastreio:", err);
          alert("Não foi possível atualizar o código de rastreio.");
        }
      };

      window.deleteOrder = async (id) => {
        if (!confirm("Excluir este pedido? Essa ação não poderá ser desfeita.")) {
          return;
        }

        try {
          await db.collection("orders").doc(id).delete();
          loadOrders();
        } catch (err) {
          console.error("Erro ao excluir pedido:", err);
          alert("Não foi possível excluir o pedido.");
        }
      };

      loadOrders();
    });
  </script>
</body>
</html>
